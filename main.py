# -*- coding: utf-8 -*-
"""Untitled43.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17sYr6_SIEoRq8P5cjvoh5fxJunawgClA
"""

import sys
from PyQt5 import QtCore, QtGui, QtWidgets
from bfs import Graph_bfs
from dfs import Graph_dfs
from astar import Graph_astar

class Ui_AISearchingTechniquesMainWindow(object):
    def setupUi(self, AISearchingTechniquesMainWindow):
        AISearchingTechniquesMainWindow.setObjectName("AISearchingTechniquesMainWindow")
        AISearchingTechniquesMainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(AISearchingTechniquesMainWindow)
        self.centralwidget.setObjectName("centralwidget")

        # Dropdown for search algorithms
        self.comboBox = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox.setGeometry(QtCore.QRect(100, 50, 200, 25))
        self.comboBox.setObjectName("comboBox")
        self.comboBox.addItem("BFS")
        self.comboBox.addItem("DFS")
        self.comboBox.addItem("A* Search")

        # Text area to input the graph or nodes
        self.textEditInput = QtWidgets.QTextEdit(self.centralwidget)
        self.textEditInput.setGeometry(QtCore.QRect(100, 100, 600, 150))
        self.textEditInput.setObjectName("textEditInput")

        # Button to start the search
        self.pushButtonStart = QtWidgets.QPushButton(self.centralwidget)
        self.pushButtonStart.setGeometry(QtCore.QRect(350, 300, 100, 25))
        self.pushButtonStart.setObjectName("pushButtonStart")

        # Text area to show results/output
        self.textEditOutput = QtWidgets.QTextEdit(self.centralwidget)
        self.textEditOutput.setGeometry(QtCore.QRect(100, 350, 600, 150))
        self.textEditOutput.setObjectName("textEditOutput")

        AISearchingTechniquesMainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(AISearchingTechniquesMainWindow)
        QtCore.QMetaObject.connectSlotsByName(AISearchingTechniquesMainWindow)

        # Connect the button to the search function
        self.pushButtonStart.clicked.connect(self.runSearchAlgorithm)

    def retranslateUi(self, AISearchingTechniquesMainWindow):
        _translate = QtCore.QCoreApplication.translate
        AISearchingTechniquesMainWindow.setWindowTitle(_translate("AISearchingTechniquesMainWindow", "AI Searching Techniques"))
        self.pushButtonStart.setText(_translate("AISearchingTechniquesMainWindow", "Start Search"))

    def runSearchAlgorithm(self):
        # Get the selected algorithm
        algorithm = self.comboBox.currentText()
        # Get the input graph from the text edit
        input_data = self.textEditInput.toPlainText()

        # For demonstration, assume input data format is simple and parsed directly into lists of edges.
        # In a real application, you'd parse this input more robustly.
        start_node = 'A'
        end_node = 'G'
        edges = [
            ('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'E'),
            ('D', 'F'), ('E', 'G'), ('F', 'G')
        ]

        if algorithm == "BFS":
            graph = Graph_bfs(edges)
            result = graph.bfs(start_node, end_node)
        elif algorithm == "DFS":
            graph = Graph_dfs(edges)
            result = graph.dfs(start_node, end_node)
        elif algorithm == "A* Search":
            graph = Graph_astar(edges)
            result = graph.a_star(start_node, end_node)

        # Display the result in the output area
        self.textEditOutput.setText("Result using " + algorithm + ": " + str(result))

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    AISearchingTechniquesMainWindow = QtWidgets.QMainWindow()
    ui = Ui_AISearchingTechniquesMainWindow()
    ui.setupUi(AISearchingTechniquesMainWindow)
    AISearchingTechniquesMainWindow.show()
    sys.exit(app.exec_())

class Graph_bfs:
    def __init__(self, edges):
        self.graph = {}
        for u, v in edges:
            if u not in self.graph:
                self.graph[u] = []
            self.graph[u].append(v)
            if v not in self.graph:
                self.graph[v] = []
            self.graph[v].append(u)

    def bfs(self, start, goal):
        visited = set()
        queue = [[start]]

        if start == goal:
            return [start]

        while queue:
            path = queue.pop(0)
            node = path[-1]
            if node not in visited:
                neighbors = self.graph[node]
                for neighbor in neighbors:
                    new_path = list(path)
                    new_path.append(neighbor)
                    queue.append(new_path)

                    if neighbor == goal:
                        return new_path
                visited.add(node)
        return "No path found"

class Graph_dfs:
    def __init__(self, edges):
        self.graph = {}
        for u, v in edges:
            if u not in self.graph:
                self.graph[u] = []
            self.graph[u].append(v)
            if v not in self.graph:
                self.graph[v] = []
            self.graph[v].append(u)

    def dfs(self, start, goal, path=None, visited=None):
        if path is None:
            path = [start]
        if visited is None:
            visited = set()

        visited.add(start)

        if start == goal:
            return path

        for neighbor in self.graph[start]:
            if neighbor not in visited:
                result = self.dfs(neighbor, goal, path + [neighbor], visited)
                if result:
                    return result

        return "No path found"

import heapq

class Graph_astar:
    def __init__(self, edges):
        self.graph = {}
        self.h = {}  # Heuristic values for nodes (for simplicity, we use a dummy heuristic)
        for u, v in edges:
            if u not in self.graph:
                self.graph[u] = []
            self.graph[u].append(v)
            if v not in self.graph:
                self.graph[v] = []
            self.graph[v].append(u)
            self.h[u] = 1  # All nodes have a heuristic value of 1 in this example
            self.h[v] = 1

    def a_star(self, start, goal):
        open_set = []
        heapq.heappush(open_set, (0, start))
        came_from = {start: None}
        g_score = {start: 0}

        while open_set:
            current = heapq.heappop(open_set)[1]

            if current == goal:
                return self.reconstruct_path(came_from, current)

            for neighbor in self.graph[current]:
                tentative_g_score = g_score[current] + 1

                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                    g_score[neighbor] = tentative_g_score
                    f_score = tentative_g_score + self.h[neighbor]
                    heapq.heappush(open_set, (f_score, neighbor))
                    came_from[neighbor] = current

        return "No path found"

    def reconstruct_path(self, came_from, current):
        total_path = [current]
        while came_from[current]:
            current = came_from[current]
            total_path.insert(0, current)
        return total_path